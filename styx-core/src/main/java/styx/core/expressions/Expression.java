package styx.core.expressions;

import java.util.EnumSet;
import java.util.List;

import styx.Determinism;
import styx.StyxException;
import styx.Value;
import styx.core.values.CompiledComplex;

/**
 * Abstract base class for nodes of the abstract syntax tree.
 * <p>
 * Expressions are generated by the parser and evaluated by the interpreter.
 */
public abstract class Expression extends CompiledComplex {

    /**
     * Compiles the expression.
     * <p>
     * Compilation is necessary before a parsed expression can be evaluated.
     * It includes type checks and optimizations such as constant propagation or other computations.
     * @param scope contains information about global symbols, function arguments and local variables.
     * @param flags indicates how the expression is used and which subexpressions it may contain.
     * @return the compiled expression, either this expression if no optimizations or computations where performed or
     *         a new, semantically equivalent, optimized expression.
     * @throws StyxException if compilation failed, usually due to a reference to an undefined symbol or
     *                      due to a typing problem.
     */
    public abstract Expression compile(Scope scope, EnumSet<CompileFlag> flags) throws StyxException;

    /**
     * Indicates which side effects a compiled expression can have.
     * <p>
     * Expressions that are CONSTANT and calls to PURE functions can be compile-time optimized.
     * @return the determinism of a compiled expression,
     *         generally the maximum value of all its nested sub-expressions.
     */
    public abstract Determinism effects();

    /**
     * Evaluates the expression and returns the result.
     * @param stack contains all function arguments and local variables.
     * @return the resulting value of the expression, can be null.
     * @throws StyxException if an exception was thrown during the evaluation of the expression,
     *                      either by a 'throw', by a called intrinsic function or by the interpreter.
     */
    public abstract Value evaluate(Stack stack) throws StyxException;

    /**
     * Executes the statement.
     * @param stack contains all function arguments and local variables.
     * @return null if execution completed normally,
     *         or non-null if a control flow statement such as 'return' or 'break' was executed.
     * @throws StyxException if an exception was thrown during the evaluation of the expression,
     *                      either by a 'throw', by a called intrinsic function or by the interpreter.
     */
    public Flow execute(Stack stack) throws StyxException {
        // This simple implementation _can_ be overridden by subclasses for optimization.
        // It _must_ be overridden when control flow statements are to be handled.
        evaluate(stack);
        return null;
    }

    protected static void requireFlag(EnumSet<CompileFlag> flags, CompileFlag required, String message) throws StyxException {
        if(!flags.contains(required)) {
            throw new StyxException(message);
        }
    }

    protected final Expression optimizeConst(Scope scope) {
        if(effects() == Determinism.CONSTANT) {
            try {
                return new Constant(evaluateConst(scope)); // optimization possible.
            } catch (RuntimeException | StyxException e) {
                return this; // optimization possible, but evaluation leads to an exception (this is not optimized).
            }
        } else {
            return this; // optimization not possible.
        }
    }

    protected final Value evaluateConst(Scope scope) throws StyxException {
        return evaluate(new Stack(scope.getSession()));
    }

    protected static Determinism maxEffects(Determinism det1, Determinism det2) {
        return det1.ordinal() >= det2.ordinal() ? det1 : det2;
    }

    protected static Determinism maxEffects(Determinism det, Expression... exprs) {
        for(Expression expr : exprs) {
            if(expr != null) {
                det = maxEffects(det, expr.effects());
            }
        }
        return det;
    }

    protected static Determinism maxEffects(Expression... exprs) {
        return maxEffects(Determinism.CONSTANT, exprs);
    }

    protected static <T extends Expression> Determinism maxEffects(List<T> exprs) {
        return maxEffects(exprs.toArray(new Expression[0]));
    }
}
